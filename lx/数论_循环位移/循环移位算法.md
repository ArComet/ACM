# 循环位移算法

https://blog.csdn.net/tianmohust/article/details/9413057

对于第三种方法，王晓东老师在著作中介绍了一条循环置换分解定理：对于给定数组A[0..N-1]向后循环换位N-K位运算，可分解为恰好gcd(K,N-K)个循环置换，且0,...,gcd(K,N-K)-1中的每个数恰属于一个循环置换。其中gcd(x,y)表示x和y的最大公因数。

我们从头开始分析这个问题，对于数组A[0..n-1]，要将其向后循环移动k位元素。因为每个元素右移n位后又回到了原来的位置上，所以右移k位等于右移k mod n位。考虑每个元素右移k位后的最终位置，比如对于A[0]，右移k位后在k mod n位置上，原来在k mod n位置上的元素右移k位后到了2*k mod n的位置上，把如此因为A[0]的移动而受到连环影响必须移动的位置列出来，就是下面这样一个位置序列：0,k,2*k,...,(t-1)k。其中每一项都是在模n的意义下的位置。t*k mod n 的结果是0。t是使得t*k mod n的结果为0的最小正整数。

这个位置序列实质上是模n加法群中由元素k生成的一个循环子群。由群论中的结论(该结论的证明见最后)知，循环子群(k)的周期为n / gcd(k,n)，元数为n / gcd(k,n)，其陪集个数为gcd(k,n)。换句话说，A[0..n-1]循环右移k位的结果是循环子群(k)以及它的所有陪集循环右移一位。例如，将A[0..5] = {1,2,3,4,5,6}循环右移4位，这里n = 6, k = 4, gcd(k, n) = 2。A[0]的最终位置是4,A[4]的最终位置是2,A[2]的最终位置是0，这样，位置0,4,2便是由k=4生成的循环群，周期为6 / gcd(4,6) = 6 / 2 = 3，这样的循环子群共有gcd(4,6) = 2个。
